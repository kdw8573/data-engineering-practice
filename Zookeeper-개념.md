- [Zookeeper 개념](#zookeeper-개념)
  - [Zookeeper](#zookeeper)
  - [Zookeeper Architecture](#zookeeper-architecture)
  - [트랜잭션 처리](#트랜잭션-처리)
  - [쿼럼 과반수](#쿼럼-과반수)
  - [데이터 모델](#데이터-모델)
  - [Watcher](#watcher)
  - [주키퍼의 용도](#주키퍼의-용도)

# Zookeeper 개념

## Zookeeper
* 과거에는 한 대의 컴퓨터에서 동작하는 단일 프로그램이 대다수였지만, 현재는 빅데이터와 클라우드 환경에서 대규모의 시스템들이 동작. 대규모 시스템은 수많은 서버와 인프라로 구성되어 있음.
* 이 개별적인 시스템들을 각각 조율해야하는 코디네이션 시스템(분산된 환경에서 부하 관리, 락이나 동기화 문제, 장애상황 판단 문제 등)의 수요 발생. 
* 주키퍼는(Zookeeper)는 분산 코디네이션 서비스를 제공하는 오픈소스 프로젝트. 아파치 하둡프로젝트의 서브프로젝트로 시작하여 메인프로젝트로 승격.
* 주키퍼라는 이름이 붙여진 것은 하둡의 서브프로젝트가 코끼리(hadoop), 거북이(chunkwa), 돼지(pig) 등 동물 이름을 많이 따라 지었기 때문에, 주키퍼의 역할이 사육사처럼 다양한 서버로 구성된 분산 서버들을 잘 관리하고 조율하는 기능을 수행하는 것.

## Zookeeper Architecture
* 주키퍼는 분산 환경을 쉽게 관리하는 기능을 제공하지만 주키퍼 역시 여러대의 서버로 구성된 분산 시스템.
* 이러한 서버 구조를 Ensemble(앙상블)이라 부르며, leader-follower 형태를 가짐.
* 클라이언트가 특정 서버에 접속하여 데이터를 업데이트하며, 업데이트 된 서버는 leader의 역할을 맡은 주키퍼 서버에 그 데이터를 알림.
* 업데이트를 감지한 leader 서버는 그 정보를 다른 곳에 브로드캐스트(Broadcast) 형식으로 알림. 나머지 Follower 주키퍼 서버들은 그 내용을 갱신하여 전체 서버들의 데이터들이 일관된 상태로 유지.
![zookeeper](https://open.oss.navercorp.com/storage/user/1981/files/58311572-7431-4f36-849c-bfc502838255)

## 트랜잭션 처리
1. 새로운 트랜잭션 요청이 Follower에게 도착하였을 경우, Follower는 Leader에게 요청을 전달.
2. Propose : Leader가 Quorum을 구성하는 서버들에게 트랙잭션을 수행해도 되는지 여부를 요청
> * Leader가 새로운 트랜잭션을 수행하기 위해서는 자신을 포함하여 과반수 이상의 서버의 합의를 얻어야 한다. 
> * 과반수의 합의를 위해 필요한 서버들을 Quorum이라고 한다. Ensemble을 구성하는 서버의 수가 5개라면, Quorum은 3개의 서버로 구성.
3. Quorum을 구성하는 서버들은 Leader로 부터 Propose 요청을 받으면, 트랙잭션을 수행해도 된다는 Ack 응답을 Leader에게 전송.
4. 모든 Quorum으로 부터 Ack를 받으면, Leader는 트랙잭션을 처리하라는 Commit 명령을 broadcast 형태로 모든 Follower에 전파.

## 쿼럼 과반수
* 서버가 5대이고, 쿼럼이 3개라고 가정할 경우 예시.
1. client가 주키퍼에게 쓰기 작업을 요청.
2. 주키퍼는 쓰기 요청을 리더에게 보내고, 리더는 다시 쿼럼(3대)으로 트랜잭션 여부 요청.
3. 쿼럼에 쓰기 작업 요청이 복제되면 리더에게 ACK 반환.
4. 이 때, 쿼럼 중 2대의 서버에 장애가 발생.
5. 주키퍼는 쿼럼으로 구성되었던 서버 1대와 쿼럼에 포함되지 않았던 서버 2대로 새로운 쿼럼을 구성.
6. 쿼럼으로 구성되었던 서버 1대는 client가 요청한 쓰기 작업을 알고 있음.
7. client가 쓰기 작업 요청을 새롭게 구성된 쿼럼에 포함된 다른 서버들에게 복제.
8. 그래서 주키퍼는 장애상황에도 작업을 유실하지 않음.
* 만약 쿼럼 전부가 장애가 날 경우에는 남은 서버 2대로는 쿼럼을 구성할 수 없으므로 주키퍼는 이용 불가.

## 데이터 모델
* 모든 데이터는 서버 메모리에 존재하기 때문에 전체 데이터 용량은 힙 메모리 사이즈를 초과 못 함.
* 주키퍼에는 시스템관리, 모니터링, 락 관리 등에 필요한 메타 정보만 저장 하는 것이 일반적.
* 계층적인 네임스페이스에서의 각 노드를 z노드라고 부름.
> * Persistence znode: 주키퍼 서버의 로컬디스크에 저장이되고, 클라이언트의 삭제 요청에 의해서만 삭제. 이 znode를 만든 클라이언트의 접속이 끊어져도 계속 주키퍼 데이터 모델에 남아있음.
> * Ephemeral znode: 이 znode를 만든 클라이언트의 접속이 끊기면 데이터 모델 상에서 사라짐. 자식을 가질 수 없으며, 부모노드는 반드시 영속성 노드여야 함.
> * Sequential znode: 이 znode는 10자리 연속된 숫자를 가지고 있는 이름을 가지고 만들어짐. atomic하게 증가하기 때문에, 동일한 이름의 znode를 생성하여도 부여받는 순번이 달라 결과적으로 다른 이름을 갖게 된다. 분산된 노드에서 유일한 값을 생성할 수 있음.
* z노드는 stat 속성을 가지고 있으며 znode의 메타데이터(metadata)를 제공.
> * version number: znode의 데이터가 업데이트 될 때마다 버전 넘버는 계속 업데이트.
> * ACL(Action control list): ACL은 znode에 접근하기 위한 권한 획득 메커니즘. 권한을 통해 znode의 읽기 쓰기 연산을 통제. 접근 권한은 (schema:id, permission) 같은 형태로 설정.
> * 타입스탬프(Timestamp) : znode가 생성되고 나서 경과된 시간 및 업데이트된 시간 제공.
* ZooKeeper는 여러 서버에 분산되어 있는 znode를 관리하기 위한 서비스
![zookeeper model](https://open.oss.navercorp.com/storage/user/1981/files/fe56eae6-d428-49b3-b426-9fb98c3af1e3)

## Watcher
* ZooKeeper는 znode에 변화를 감지할 수 있는 Watcher를 클라이언트가 설정할 수 있도록 한다. 
* Watcher는 자신이 감시하고 있는 znode에 수정이 발생하였을 때, 클라이언트로 callback 호출을 전송하는 알림 기능을 제공.

## 주키퍼의 용도
* Queue: Watcher와 Sequence Node의 특성을 활용하면 간단한 큐를 만들 수 있다.
* 서버 설정 정보 반영: 클러스터를 구성하는 서버의 설정 정보에 수정이 발생한 경우, ZooKeeper를 활용한 분산 합의를 통해 안전하게 수정 내역을 반영할 수 있다.
* 클러스터 상태 정보 반영: 클러스터를 구성하는 서버의 상태 정보를 Ephemeral Node에 저장하면, 서버와의 연결이 끊어진 경우 해당 데이터가 삭제된다. 이를 통해, 실시간으로 클러스터 상태 정보를 업데이트 할 수 있다. 또한 Leader를 선출하는 목적으로도 쓰일 수 있다.(ex. kafka controller) 
